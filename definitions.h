/*
 * definitions.h
 *
 *  Created on: Nov 15, 2019
 *      Author: krad2
 */

#ifndef DEFINITIONS_H_
#define DEFINITIONS_H_

#include <msp430.h>

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <config.h>

#include <pool.h>
#include <list.h>
#include <queue.h>
#include <pqueue.h>

/* Determine structure sizes */

#if defined(__LARGE_DATA_MODEL__)
	typedef uint32_t word_t;
#else
	typedef uint16_t word_t;
#endif

#if defined(__LARGE_CODE_MODEL__)
	typedef uint32_t pc_t;
#else
	typedef uint16_t pc_t;
#endif

/**
 * MSP430 Trapframe
 * - Generated by the hardware on an interrupt
 * - Contains PC + SR
 */

typedef union __attribute__((packed)) {
	uint32_t value;
	uint16_t words[2];

	/**
	 * CPUX Trapframe (20-bit)
	 * - SP + 2: PC[15:0]
	 * - SP: PC[19:16], SR
	 *
	 * CPU Trapframe (16-bit)
	 * - SP + 2: PC[15:0]
	 * - SP: SR
	 */

	#if defined(__LARGE_CODE_MODEL__)

	struct {
		unsigned int sr : 12;
		unsigned int pc_high : 4;
		unsigned int pc_low : 16;
	};

	#else

	struct {
		unsigned int sr : 16;
		unsigned int pc : 16;
	};

	#endif
} hw_stackframe_t;

/**
 * Software stackframe / register states
 * - Calling convention requires r4-r11 to be saved
 * - Additionally saving the scratch registers because the kernel may not corrupt these
 */

typedef struct sw_stackframe_t {
	word_t r4;
	word_t r5;
	word_t r6;
	word_t r7;
	word_t r8;
	word_t r9;
	word_t r10;
	word_t r11;
	word_t r12;
	word_t r13;
	word_t r14;
	word_t r15;
} sw_stackframe_t;

struct thrd_t;

/**
 * Defines the thread 'waiting queue' structure used by semaphores under the hood
 */

QUEUE(wait, struct thrd_t *, NUM_THREADS);

/**
 * Semaphore object using a queue sized to the number of threads
 */

typedef struct sem_t {
	int8_t val;
	struct queue_wait wq;
} sem_t;

/**
 * Mutex object using a queue sized to the number of threads
 */

typedef struct mtx_t {
	struct thrd_t *holder;
	struct queue_wait wq;
} mtx_t;

/**
 * Defines the thread 'sleeping queue' structure used by sleeping threads
 */

struct sleep_deadline {
	struct thrd_t *data;
	size_t ticks;
};

PQUEUE(sleep, struct sleep_deadline, NUM_THREADS);
PQUEUE(timedwait, struct sleep_deadline, NUM_THREADS);

/**
 * Thread struct: contains context and data stack
 */

typedef enum thrd_state_t {
	ACTIVE,
	KILLED,
	SLEEPING,
	BLOCKING
} thrd_state_t;

typedef struct thrd_t {
	word_t sp;
	uint16_t stack[STACKSIZE];

	pc_t ret_addr;		// Thread exit address at the edge of the stack
	sem_t join_sem;

	int mbox;

	size_t base_prio;
	size_t fixed_prio;
	size_t working_prio;

	thrd_state_t state;
} thrd_t;

/**
 * OS task table structure used by the OS to manage data
 */

typedef struct task {
	thrd_t thread;
	struct list_element elem;
} os_task_t;

POOL(task_mem, os_task_t, NUM_THREADS);

#endif /* DEFINITIONS_H_ */
